# 모든 개발자를 위한 HTTP 웹 기본 지식

인터넷 통신을 하는 것은 어렵다.  
어떤 규칙으로 인터넷을 통해 통신할까?

인터넷은 단순하지 않아서 수많은 중간 노드(서버)를 거쳐서 통신하게 된다.  
그럼 어떤 규칙으로 어떻게 통신이 되는걸까?

<br>

## 인터넷 네트워크

### IP (인터넷 프로토콜)

지정된 IP 주소로 데이터(패킷)를 전달한다.

패킷에는 나의 IP주소, 목적지 IP주소, 전달할 내용이 담겨있다.  
목적지 IP주소가 담겨있기 때문에 중간 노드를 거쳐 목적지로 전달될 수 있다!

<br>

하지만 IP만으로는 한계가 있는데 이유는 다음과 같다
```
패킷을 받을 대상이 서비스 불능 상태여도 패킷이 전손된다.
중간노드를 거치는 과정에서 패킷이 사라질 수도 있다.
내가 의도한대로 전송되지 않고 패킷의 순서가 섞인 상태로 전달 될 수 있다
```
이같은 문제들을 해결하기 위해 TCP/UDP를 사용한다!

<br>

### TCP

전송 제어 프로토콜  

연결지향 (TCP 3 way handshake) 
데이터 전달 보증  
순서 보장

-> 신뢰할 수 있는 프로토콜

TCP/IP 프로토콜 4계층
```
애플리케이션 계층 - HTTP, FTP
전송 계층 - TCP, UDP
인터넷 계층 - IP
네트워크 인터페이스 계층 - LAN 드라이버, LAN 장비
```
IP의 한계를 보완하기 위해 TCP/UDP 정보를 추가한다. (Port정보, 순서등이 포함된다.)

<br>

### UDP
사용자 데이터그램 프로토콜  
Port정보, 체크섬 추가

<br>

#### Port
IP는 아파트, Port는 동/호수로 비유할 수 있다.  
같은 IP 내에서 프로세스를 구분하는 역할을 한다.

<br>

### DNS
도메인 네임 시스템  
IP주소는 기억하기 어렵기 때문에 도메인을 사용한다.  
도메인 명을 IP주소로 반환해준다.

ex)
브라우저에서 www.google.com을 치고 접속하면, DNS 서버에서 해당 도메인의 IP주소를 찾고, 해당 IP주소로 요청한다.

<br>

## URI와 웹 브라우저 요청 흐름

### URI (Uniform Resource Identifier)

URL, URN을 포함하는 개념이다.
```
Uniform Resource Location
Uniform Resource Name
```
URN은 거의 사용하지 않는다.

<br>

### 웹 브라우저 요청 흐름

브라우저에서 `https://www.google.com/search?q=hello&hl=ko`를 치고 접속하면 일어나는 일
```
1. DNS에서 해당하는 IP주소를 찾는다.
2. HTTP 요청 메시지가 생성되고 패킷에 담아 해당 IP주소로 요청한다.
3. 해당 IP주소로 패킷이 전송된다.
4. 패킷을 전송 받은 해당 IP주소는 요청 메시지에 응답하기 위해 HTTP 응답 메시지를 만들고 패킷에 담아 응답한다.
5. 응답받은 브라우저는 응답 메시지를 수행한다
```

<br>

## HTTP (HyperText Transfer Protocol)

HTTP 메세지에 거의 모든 형태의 데이터를 담아 전송할 수 있다.  
```
HTML, 영상, 이미지, JSON, 파일, 텍스트 등등
```

<br>

### HTTP 특징

#### 클라이언트 서버 구조
Request, Response구조이다.  
클라이언트는 서버에 요청을 보내고 서버가 응답해줄 때까지 기다린 후, 응답을 받고 동작한다.

<br>

#### 무상태 프로토콜 (Stateless)
서버가 클라이언트의 상태를 보존하지 않는다.

클라이언트는 서버에 필요한 정보들을 한번에 전달해주어야 한다.  
이를 통해 서버는 확장에 유리하다. (클라이언트 요청이 증가해도, 서버를 단순히 증가시키는 걸로 해결이 가능하기 때문)

**참고**
https://www.inflearn.com/questions/223034

실무에서는 가급적, 무상태로 설계하고 최소한의 부분(로그인등)만 상태 유지방식으로 설계한다.

<br>

#### 비 연결성 (Connectionless)

HTTP는 기본으로 연결을 유지하지 않는다.  
클라이언트가 서버에 요청을 하면, 서버는 요청에 대한 응답을 하고 연결을 유지하지 않고 끊어버린다.  
이로 인해 서버 자원을 매우 효율적으로 사용할 수 있게 된다.

하지만 단점도 존재하는데, 요청마다 TCP/IP 연결(3 way handshake)을 새로 맺어야 하기 때문에 시간이 낭비된다는 점과, 한 번 요청시, 많은 자원(html, css, js, 이미지등)들이 한꺼번에 다운로드된다는 점 등이 있다.

이러한 문제를 HTTP 지속 연결로 해결  
HTTP/2, HTTP/3에서 최적화

<br>

### HTTP 메시지

HTTP 메시지는 요청/응답 메시지로 구분되고 아래와 같이 구성되어 있다.
```
시작라인
HTTP 헤더
HTTP 메시지 바디
```

<br>

### HTTP API

API URI를 설계할 때, 어떤 식으로 설계를 하는게 좋을까?

가장 중요한 것은 `리소스 식별`이다.  
URI는 리소스만 식별할 수 있도록 구성하는 것이 좋다.  
식별한 리소스를 URI에 매핑한다. 

리소스와 해당 리소스를 대상으로 하는 행위를 분리한다.  
```
리소스 - 회원
행위 - 조회, 등록, 삭제, 변경
```
리소스는 명사, 행위는 동사(HTTP 메소드)로 구분한다.

<br>

**컨트롤 URI**

동사로 된 리소스 경로를 사용하는 것을 의미한다.  
ex) /new, /edit, /delete등

HTTP 메소드로 URI 설계가 어려울 경우에 사용한다.

<br>

**HTTP API - 컬렉션**

POST 기반으로 데이터 등록 시, 서버가 리소스 URI를 결정하는데, 이를 컬렉션이라고 한다.

클라이언트는 등록될 리소스의 URI를 모르며, 서버가 새로 등록될 URI를 결정하고 관리한다.

<br>

**HTTP API - 스토어**

PUT 기반 등록 시, 클라이언트가 리소스 URI를 결정하는데, 이를 스토어라고 한다.

클라이언트가 리소스 URI를 알고 있어야 하며, 클라이언트가 직접 리소스의 URI를 지정하고 관리한다.

<br>

### HTTP 메소드

클라이언트가 서버에 요청할 때 기대하는 행동을 의미한다.

HTTP 메소드 종류
```

```

<br>

#### GET
리소스를 조회한다.  
서버에 전달할 데이터는 쿼리스트링을 통해서 전달한다.  

<br>

#### POST
메시지 바디를 통해 서버로 넘어온 요청 데이터를 처리한다.  
신규 리소스 등록, 프로세스 처리등에 사용한다.

<br>

#### PUT
리소스를 대체하는 기능인데, 이미 리소스가 존재하면 덮어씌우고, 리소스가 존재하지 않으면 새로 생성한다.

주의할 점은 리소스를 완전히 대체해야 한다는 점이다.  
리소스 전체를 변경하기 때문에 일부만 변경하는 용도로는 적합하지 않다.

만약 일부만 변경하기 위해 PUT을 사용하면 일부 데이터가 소실된다.

<br>

#### PATCH
리소스를 부분만 변경한다.  
PUT은 리소스 전체를 변경하고자 할 때 사용하고, 부분만 변경할 때는 PATCH를 사용한다.

<br>

#### DELETE
리소스를 제거한다.

<br>

### HTTP 메소드 속성

#### 안전 (Safe Methods)
리소스 변경 유무로 판단한다.  

<br>

#### 멱등 (Itempotent Methods)
몇 번을 호출하던 결과가 똑같아야 한다는 특징

자동 복구 매커니즘등에 활용할 수 있다.  
ex) 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지?의 판단 근거가 된다

<br>

#### 캐시가능 (Cacheable Methods)
응답 결과 리소스를 캐시해서 사용이 가능한지 여부를 의미한다  
GET, HEAD정도만 캐시로 사용

<br>

## 클라이언트 -> 서버 데이터 전송

데이터 전달 방식은 크게 2가지로 구분할 수 있다.
```
1. 쿼리 스트링을 통한 데이터 전송
- GET
- 필터(검색어)

2. 메시지 바디를 통한 데이터 전송
- POST, PUT, PATCH
- 회원가입, 상품등록 등등
```

<br>

### 정적 데이터 조회
이미지, 정적 텍스트 문서

GET  
일반적인 리소스 경로로 조회 가능

<br>

### 동적 데이터 조회
검색 등

GET
주로 쿼리 스트링을 사용해 검색 키워드를 서버에 전달한다.

<br>

### HTML Form을 통한 데이터 전송
회원가입, 상품주문 등

POST/GET
폼을 통해 서버로 전달하며, Content-Type이 `application/x-www-form-urlencoded`로 설정되어 서버로 전달된다.

파일등을 함께 보낼 땐,
enctype을 `multipart/form-data`로 설정해야 Content-Type이 `multipart/form-data`로 설정되어 서버로 전달된다.

<br>

### HTTP API를 통한 데이터 전송
회원가입, 상품주문 등  
서버 TO 서버, AJAX

POST
요청할 URI에 application/json타입으로 메시지 바디에 JSON을 넣고 요청한다.

<br>

### HTTP API 설계 예시

HTML Form태그를 사용하면, GET, POST메소드만 사용가능하기 때문에 URI 설계 시에 제약이 있을 수 있다.  
이를 해결하기 위해 컨트롤 URI(동사로 된 리소스 경로)를 사용한다.

<br>

#### 좋은 URI 설계 개념

**문서**

단일 개념(파일 하나, 객체 인스턴스 등)  
ex) /members/100

<br>

**컬렉션**

<br>

**스토어**

<br>

**컨트롤 URI (컨트롤러)**

문서, 컬렉션, 스토어로 해결하기 어려울 때 사용한다.
ex) /members/{id}/delete

<br>

### HTTP 상태코드

클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 코드이다.

```
1xx (Informational): 요청이 수신되어 처리중

2xx (Successful): 요청 정상 처리

3xx (Redirection): 요청을 완료하려면 추가 행동이 필요

4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음

5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
```
1xx대 상태코드는 거의 사용안함

<br>

#### 2xx - 성공

```
200 Ok - 요청 성공
201 Created - 요청 성공해서 새로운 리소스가 생성됨
202 Accepted - 요청이 접수되었으나 처리가 완료되지 않았음
204 No Content - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
```
거의 200만 사용하거나, 201까지만 사용한다.

<br>

#### 3xx (Redirection)
웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다. (Redirect)

<br>

#### 4xx - 클라이언트 오류
오류의 원인이 클라이언트에 있다.

```
400 Bad Request - 클라이언트의 잘못된 요청으로 서버가 요청을 처리할 수 없음
401 Unauthorized - 클라이언트가 해당 리소스에 대한 인증이 필요함
403 Forbidden - 서버가 요청을 받았지만 승인을 거부함
404 Not Found - 요청 리소스를 찾을 수 없음
```

<br>

#### 5xx - 서버 오류
서버 문제로 오류가 발생하는 경우

```
500 Internal Server Error - 서버 문제로 오류 발생
503 Service Unavailable - 서비스 이용 불가

```

<br>
