# 모든 개발자를 위한 HTTP 웹 기본 지식

인터넷 통신을 하는 것은 어렵다.  
어떤 규칙으로 인터넷을 통해 통신할까?

인터넷은 단순하지 않아서 수많은 중간 노드(서버)를 거쳐서 통신하게 된다.  
그럼 어떤 규칙으로 어떻게 통신이 되는걸까?

<br>

## 인터넷 네트워크

### IP (인터넷 프로토콜)

지정된 IP 주소로 데이터(패킷)를 전달한다.

패킷에는 나의 IP주소, 목적지 IP주소, 전달할 내용이 담겨있다.  
목적지 IP주소가 담겨있기 때문에 중간 노드를 거쳐 목적지로 전달될 수 있다!

<br>

하지만 IP만으로는 한계가 있는데 이유는 다음과 같다
```
패킷을 받을 대상이 서비스 불능 상태여도 패킷이 전손된다.
중간노드를 거치는 과정에서 패킷이 사라질 수도 있다.
내가 의도한대로 전송되지 않고 패킷의 순서가 섞인 상태로 전달 될 수 있다
```
이같은 문제들을 해결하기 위해 TCP/UDP를 사용한다!

<br>

### TCP

전송 제어 프로토콜  

연결지향 (TCP 3 way handshake) 
데이터 전달 보증  
순서 보장

-> 신뢰할 수 있는 프로토콜

TCP/IP 프로토콜 4계층
```
애플리케이션 계층 - HTTP, FTP
전송 계층 - TCP, UDP
인터넷 계층 - IP
네트워크 인터페이스 계층 - LAN 드라이버, LAN 장비
```
IP의 한계를 보완하기 위해 TCP/UDP 정보를 추가한다. (Port정보, 순서등이 포함된다.)

<br>

### UDP
사용자 데이터그램 프로토콜  
Port정보, 체크섬 추가

<br>

#### Port
IP는 아파트, Port는 동/호수로 비유할 수 있다.  
같은 IP 내에서 프로세스를 구분하는 역할을 한다.

<br>

### DNS
도메인 네임 시스템  
IP주소는 기억하기 어렵기 때문에 도메인을 사용한다.  
도메인 명을 IP주소로 반환해준다.

ex)
브라우저에서 www.google.com을 치고 접속하면, DNS 서버에서 해당 도메인의 IP주소를 찾고, 해당 IP주소로 요청한다.

<br>

## URI와 웹 브라우저 요청 흐름

### URI (Uniform Resource Identifier)

URL, URN을 포함하는 개념이다.
```
Uniform Resource Location
Uniform Resource Name
```
URN은 거의 사용하지 않는다.

<br>

### 웹 브라우저 요청 흐름

브라우저에서 `https://www.google.com/search?q=hello&hl=ko`를 치고 접속하면 일어나는 일
```
1. DNS에서 해당하는 IP주소를 찾는다.
2. HTTP 요청 메시지가 생성되고 패킷에 담아 해당 IP주소로 요청한다.
3. 해당 IP주소로 패킷이 전송된다.
4. 패킷을 전송 받은 해당 IP주소는 요청 메시지에 응답하기 위해 HTTP 응답 메시지를 만들고 패킷에 담아 응답한다.
5. 응답받은 브라우저는 응답 메시지를 수행한다
```

<br>

## HTTP (HyperText Transfer Protocol)

HTTP 메세지에 거의 모든 형태의 데이터를 담아 전송할 수 있다.  
```
HTML, 영상, 이미지, JSON, 파일, 텍스트 등등
```

<br>

### HTTP 특징

#### 클라이언트 서버 구조
Request, Response구조이다.  
클라이언트는 서버에 요청을 보내고 서버가 응답해줄 때까지 기다린 후, 응답을 받고 동작한다.

<br>

#### 무상태 프로토콜 (Stateless)
서버가 클라이언트의 상태를 보존하지 않는다.

클라이언트는 서버에 필요한 정보들을 한번에 전달해주어야 한다.  
이를 통해 서버는 확장에 유리하다. (클라이언트 요청이 증가해도, 서버를 단순히 증가시키는 걸로 해결이 가능하기 때문)

**참고**
https://www.inflearn.com/questions/223034

실무에서는 가급적, 무상태로 설계하고 최소한의 부분(로그인등)만 상태 유지방식으로 설계한다.

<br>

#### 비 연결성 (Connectionless)

HTTP는 기본으로 연결을 유지하지 않는다.  
클라이언트가 서버에 요청을 하면, 서버는 요청에 대한 응답을 하고 연결을 유지하지 않고 끊어버린다.  
이로 인해 서버 자원을 매우 효율적으로 사용할 수 있게 된다.

하지만 단점도 존재하는데, 요청마다 TCP/IP 연결(3 way handshake)을 새로 맺어야 하기 때문에 시간이 낭비된다는 점과, 한 번 요청시, 많은 자원(html, css, js, 이미지등)들이 한꺼번에 다운로드된다는 점 등이 있다.

이러한 문제를 HTTP 지속 연결로 해결  
HTTP/2, HTTP/3에서 최적화

<br>

### HTTP 메시지

HTTP 메시지는 요청/응답 메시지로 구분되고 아래와 같이 구성되어 있다.
```
시작라인
HTTP 헤더
HTTP 메시지 바디
```

<br>

### HTTP API

API URI를 설계할 때, 어떤 식으로 설계를 하는게 좋을까?

가장 중요한 것은 `리소스 식별`이다.  
URI는 리소스만 식별할 수 있도록 구성하는 것이 좋다.  
식별한 리소스를 URI에 매핑한다. 

리소스와 해당 리소스를 대상으로 하는 행위를 분리한다.  
```
리소스 - 회원
행위 - 조회, 등록, 삭제, 변경
```
리소스는 명사, 행위는 동사(HTTP 메소드)로 구분한다.

<br>

**컨트롤 URI**

동사로 된 리소스 경로를 사용하는 것을 의미한다.  
ex) /new, /edit, /delete등

HTTP 메소드로 URI 설계가 어려울 경우에 사용한다.

<br>

**HTTP API - 컬렉션**

POST 기반으로 데이터 등록 시, 서버가 리소스 URI를 결정하는데, 이를 컬렉션이라고 한다.

클라이언트는 등록될 리소스의 URI를 모르며, 서버가 새로 등록될 URI를 결정하고 관리한다.

<br>

**HTTP API - 스토어**

PUT 기반 등록 시, 클라이언트가 리소스 URI를 결정하는데, 이를 스토어라고 한다.

클라이언트가 리소스 URI를 알고 있어야 하며, 클라이언트가 직접 리소스의 URI를 지정하고 관리한다.

<br>

### HTTP 메소드

클라이언트가 서버에 요청할 때 기대하는 행동을 의미한다.

HTTP 메소드 종류
```

```

<br>

#### GET
리소스를 조회한다.  
서버에 전달할 데이터는 쿼리스트링을 통해서 전달한다.  

<br>

#### POST
메시지 바디를 통해 서버로 넘어온 요청 데이터를 처리한다.  
신규 리소스 등록, 프로세스 처리등에 사용한다.

<br>

#### PUT
리소스를 대체하는 기능인데, 이미 리소스가 존재하면 덮어씌우고, 리소스가 존재하지 않으면 새로 생성한다.

주의할 점은 리소스를 완전히 대체해야 한다는 점이다.  
리소스 전체를 변경하기 때문에 일부만 변경하는 용도로는 적합하지 않다.

만약 일부만 변경하기 위해 PUT을 사용하면 일부 데이터가 소실된다.

<br>

#### PATCH
리소스를 부분만 변경한다.  
PUT은 리소스 전체를 변경하고자 할 때 사용하고, 부분만 변경할 때는 PATCH를 사용한다.

<br>

#### DELETE
리소스를 제거한다.

<br>

### HTTP 메소드 속성

#### 안전 (Safe Methods)
리소스 변경 유무로 판단한다.  

<br>

#### 멱등 (Itempotent Methods)
몇 번을 호출하던 결과가 똑같아야 한다는 특징

자동 복구 매커니즘등에 활용할 수 있다.  
ex) 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지?의 판단 근거가 된다

<br>

#### 캐시가능 (Cacheable Methods)
응답 결과 리소스를 캐시해서 사용이 가능한지 여부를 의미한다  
GET, HEAD정도만 캐시로 사용

<br>

## 클라이언트 -> 서버 데이터 전송

데이터 전달 방식은 크게 2가지로 구분할 수 있다.
```
1. 쿼리 스트링을 통한 데이터 전송
- GET
- 필터(검색어)

2. 메시지 바디를 통한 데이터 전송
- POST, PUT, PATCH
- 회원가입, 상품등록 등등
```

<br>

### 정적 데이터 조회
이미지, 정적 텍스트 문서

GET  
일반적인 리소스 경로로 조회 가능

<br>

### 동적 데이터 조회
검색 등

GET
주로 쿼리 스트링을 사용해 검색 키워드를 서버에 전달한다.

<br>

### HTML Form을 통한 데이터 전송
회원가입, 상품주문 등

POST/GET
폼을 통해 서버로 전달하며, Content-Type이 `application/x-www-form-urlencoded`로 설정되어 서버로 전달된다.

파일등을 함께 보낼 땐,
enctype을 `multipart/form-data`로 설정해야 Content-Type이 `multipart/form-data`로 설정되어 서버로 전달된다.

<br>

### HTTP API를 통한 데이터 전송
회원가입, 상품주문 등  
서버 TO 서버, AJAX

POST
요청할 URI에 application/json타입으로 메시지 바디에 JSON을 넣고 요청한다.

<br>

### HTTP API 설계 예시

HTML Form태그를 사용하면, GET, POST메소드만 사용가능하기 때문에 URI 설계 시에 제약이 있을 수 있다.  
이를 해결하기 위해 컨트롤 URI(동사로 된 리소스 경로)를 사용한다.

<br>

#### 좋은 URI 설계 개념

**문서**

단일 개념(파일 하나, 객체 인스턴스 등)  
ex) /members/100

<br>

**컬렉션**

<br>

**스토어**

<br>

**컨트롤 URI (컨트롤러)**

문서, 컬렉션, 스토어로 해결하기 어려울 때 사용한다.
ex) /members/{id}/delete

<br>

### HTTP 상태코드

클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 코드이다.

```
1xx (Informational): 요청이 수신되어 처리중

2xx (Successful): 요청 정상 처리

3xx (Redirection): 요청을 완료하려면 추가 행동이 필요

4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음

5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
```
1xx대 상태코드는 거의 사용안함

<br>

#### 2xx - 성공

```
200 Ok - 요청 성공
201 Created - 요청 성공해서 새로운 리소스가 생성됨
202 Accepted - 요청이 접수되었으나 처리가 완료되지 않았음
204 No Content - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
```
거의 200만 사용하거나, 201까지만 사용한다.

<br>

#### 3xx (Redirection)
웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다. (Redirect)

```
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
307 Temporary Redirect
308 Permanent Redirect
```

<br>

**영구 리다이렉션**

특정 리소스의 URI가 영구적으로 이동한 경우  
리소스 URI가 영구적으로 이동

```
301 Moved Permanently
- 리다이렉트시 요청 메소드가 GET으로 변하고, 본문이 제거될 수 있다.

308 Permanent Redirect
- 301과 기능이 같고, 차이점은 리다이렉트시 요청 메소드와 본문 유지한다.
```

<br>

**일시 리다이렉션**

특정 리소스의 URI를 일시적으로 변경하는 것  
ex) 주문 완료 후, 주문 내역 화면으로 이동시키기

```
302 Found
- 리다이렉트시 요청 메소드가 GET으로 변하고, 본문이 제거될 수 있다.

307 Temporary Redirect
- 302와 기능이 같고, 차이점은 리다이렉트시 요청 메소드와 본문 유지한다.

303 See Other
- 302와 기능이 같고, 리다이렉트시 요청 메소드가 GET으로 변경된다는 것을 명확하게 해놓은 것이다.
```
주로 302를 많이 쓴다.

<br>

PRG(Post/Redirect/Get) 패턴

POST로 주문후에, 새로 고침으로 인한 중복 주문을 방지하는 예시에 적용될 수 있는 패턴이다.

POST로 주문후에 주문 결과 화면을 GET 메소드로 리다이렉트한다.  
이렇게 하면, 새로고침해도 중복 주문이 되지 않고 결과 화면을 GET으로 조회하기 때문에 중복 주문이 되지 않는다!

URL이 이미 POST -> GET으로 리다이렉트 되었기 때문에, 새로고침을 해도 GET으로 결과 화면만 조회된다.

<br>

**특수 리다이렉션**

결과 대신 캐시를 사용하는 것

```
300 Multiple Choices
- 안씀

304 Not Modified
- 캐시를 목적으로 사용한다.
- 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에
저장된 캐시를 재사용한다 (캐시로 리다이렉트 함)
```

<br>

#### 4xx - 클라이언트 오류
오류의 원인이 클라이언트에 있다.

```
400 Bad Request - 클라이언트의 잘못된 요청으로 서버가 요청을 처리할 수 없음
401 Unauthorized - 클라이언트가 해당 리소스에 대한 인증이 필요함
403 Forbidden - 서버가 요청을 받았지만 승인을 거부함
404 Not Found - 요청 리소스를 찾을 수 없음
```

<br>

#### 5xx - 서버 오류
서버 문제로 오류가 발생하는 경우

```
500 Internal Server Error - 서버 문제로 오류 발생
503 Service Unavailable - 서비스 이용 불가

```

<br>

## HTTP 헤더

HTTP 전송에 필요한 모든 부가정보를 담고 있다.  
ex) 메시지 바디 내용, 크기, 압축, 인증 등등

HTTP 헤더 분류
```
General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close
Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)
Response 헤더: 응답 정보, 예) Server: Apache
Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423
```

엔티티(Entity) -> 표현(Representation)으로 변경됨  
표현은 표현 메타데이터 + 표현데이터로 구성된다.

표현은 요청이나 응답에서 전달할 실제 데이터를 의미하고 표현 헤더에서는 표현 데이터를 해석할 수 있는 정보를 제공한다.

메시지 본문(body)(페이로드)을 통해 표현 데이터를 전달한다.

<br>

### 표현의 헤더
```
Content-Type: 표현 데이터의 형식
Content-Encoding: 표현 데이터의 압축 방식
Content-Language: 표현 데이터의 자연 언어
Content-Length: 표현 데이터의 길이
```

<br>

### 협상 (콘텐츠 네고시에이션)

클라이언트가 원하는 표현으로 달라고 서버에게 요청하는 것

```
Accept: 클라이언트가 선호하는 미디어 타입 전달
Accept-Charset: 클라이언트가 선호하는 문자 인코딩
Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
Accept-Language: 클라이언트가 선호하는 자연 언어
```

<br>

#### 우선순위
Quality Values(q) 값을 사용해서 우선순위를 정한다.  
0~1, 클수록 높은 우선순위를 가진다.

ex) Acept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

<br>

### 전송 방식

```
Content-Length 단순 전송

Content-Enoding 압축 전송

Transfer-Encoding 분할 전송

Range, Content-Range 범위 전송
```

<br>

### 일반 정보

```
From: 유저 에이전트의 이메일 정보
Referer: 이전 웹 페이지 주소
User-Agent: 유저 에이전트 애플리케이션 정보
Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
Date: 메시지가 생성된 날짜
```

<br>

### 특별한 정보

```
Host: 요청한 호스트 정보(도메인)
Location: 페이지 리다이렉션
Allow: 허용 가능한 HTTP 메서드
Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
```

<br>

### 인증

```
Authorization: 클라이언트 인증 정보를 서버에 전달
WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의
401 Unauthorized 응답과 함께 사용한다
```

<br>

### 쿠키

```
Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
```

<br>

### 검증 헤더, 조건부 요청 헤더

클라이언트의 요청에 대해 서버가 응답을 줄 때, `Last-Modified` 헤더를 추가해서 응답해준다.  
응답이 브라우저의 캐시에 저장되고, 클라이언트가 요청할 때 캐시가 만료되면, `if-modified-since` 헤더를 추가해서 서버에 요청한다.  
서버는 요청을 받고, 클라이언트가 요청하는 데이터가 수정되지 않았다면 304 상태코드(데이터가 변경되지 않았으니 캐시를 재활용해도 된다는 의미)를 응답해준다.

클라이언트는 캐시의 정보를 갱신하고, 재활용한다.

`if-modified-since`, `Last-Modified`헤더를 사용하는 것의 단점은, 날짜 기반이기 때문에, 데이터를 수정했지만 내용은 같고, 날짜만 바뀌었을 때, 변경되었다고 판단하고 다시 데이터를 내려준다는 것이다.

이를 보완하기 위해 `ETag`, `if-none-match`헤더를 사용한다.

`ETag`는 캐시에 임의의 고유한 버전 이름을 정하는 것이다.  
데이터가 변경되면 이 이름을 바꾸면 된다.  
그래서, ETag를 보내서 같으면 유지하고, 다르면 다시 받으면 된다.

<br>

### 캐시 제어 헤더

```
Cache-Control: 캐시 제어
Pragma: 캐시 제어(하위 호환)
Expires: 캐시 유효 기간(하위 호환)
```
Cache-Control 사용을 권장

<br>

Cache-Control: max-age
- 캐시 유효시간을 초 단위로 정한다.

Cache-Control: no-cache
- 데이터는 캐시되지만, 만료시간을 적지 않기에 서버의 검증을 받아야 한다.

Cache-Control: no-store
- 데이터에 민감한 정보가 있다는 의미로, 저장하면 안된다